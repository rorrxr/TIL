## 🔐 6장. 키-값 저장소 설계

## 1. 키-값 저장소란?

- 고유한 키를 통해 데이터를 저장하고 조회하는 구조
- 대표적 기술: **Redis, Memcached, DynamoDB**
- 키는 일반 텍스트 또는 해시 값, 값은 어떤 데이터든 가능

## 2. 설계 시 고려사항

- 키-값 쌍의 크기: 10KB 이하
- 큰 데이터 저장 지원
- 고가용성: 빠른 응답 필수
- 자동 확장성 (서버 추가/삭제)
- 일관성 조절 가능
- 짧은 응답 지연시간 유지


## 3. 단일 vs 분산 저장소

### 🚫 단일 서버 방식의 한계

- 메모리 한계로 대규모 데이터 저장 어려움
- 장애 발생 시 전체 시스템 중단

### ✅ 분산 키-값 저장소

- 데이터를 여러 서버에 분산 저장
- 대용량 데이터, 고트래픽 환경에 적합

## 4. 핵심 개념

###  CAP 이론

- **Consistency(일관성)**: 모든 노드에서 동일한 결과 반환
- **Availability(가용성)**: 항상 응답을 반환함
- **Partition Tolerance(파티션 감내성)**: 네트워크 장애 상황에서도 시스템 유지

→ 이 셋을 동시에 만족하는 것은 불가능 (CA 시스템은 실무에서는 존재하지 않음)

### 시스템 분류 예시

- **CP 시스템**: 은행, 결제 시스템 (일관성 중시)
- **AP 시스템**: SNS, 로그 저장 시스템 (가용성 중시)

### 5. 분산 시스템 구성요소

### 데이터 파티셔닝

- 데이터를 균등하게 나누는 방식
- 안정 해시(Consistent Hashing)로 서버 추가/삭제에 유연하게 대응

### 데이터 복제

- 여러 노드에 데이터 복사로 장애 대비
- 예: 3개의 노드(n1, n2, n3)에 동일한 키 복제

### 일관성 유지 전략

- **Quorum Read/Write**: 정족수 기반 쓰기/읽기 합의
- **버전 관리(Versioning)**: 충돌 감지를 위한 버전 태그

### 장애 처리 기법

- **Gossip Protocol**: 노드 간 상태 주기적 전파
- **Hinted Handoff**: 임시 저장 후 원래 노드로 복구
- **Merkle Tree**: 데이터 불일치 감지 및 동기화

## 6. 아키텍처 흐름

### 쓰기 경로

1. 클라이언트가 `put(key, value)` 요청
2. 코디네이터 노드가 적절한 노드에 쓰기 요청 전달
3. 정족수 이상 노드에 쓰기 성공 시 완료

### 읽기 경로

1. 클라이언트가 `get(key)` 요청
2. 여러 노드에서 값을 읽고 최신 데이터 선택