## 들어가며: 왜 데이터 중심인가?

오늘날 많은 애플리케이션은 **CPU 연산 성능**보다는 **데이터 중심적 문제**에 부딪힙니다.

"얼마나 빨리 계산하느냐"보다 **데이터의 양, 복잡성, 변화 속도**가 더 큰 도전 과제가 되었습니다.

대부분의 애플리케이션은 다음과 같은 기능을 공통적으로 필요로 합니다.

- 데이터를 저장하고 다시 찾아오기 (**Database**)
- 결과를 재사용하기 위해 캐싱 (**Cache**)
- 빠른 검색과 필터링을 위한 인덱스 (**Search Index**)
- 서비스 간 메시지 전달 (**Stream / Message Queue**)
- 대량 데이터를 분석하는 일괄 처리 (**Batch Processing**)

이처럼 많은 시스템 구성 요소가 필요하기 때문에, 이제 우리는 단순히 **개발자**가 아니라 **데이터 시스템 설계자**이기도 합니다.

## 데이터 시스템의 경계가 흐려진다

예전에는 **데이터베이스(DB)**, **캐시**, **메시지 큐** 등을 별개의 범주로 생각했지만, 최근에는 경계가 모호해지고 있습니다.

- **Redis**: 캐시이지만 메시지 큐처럼 사용되기도 함
- **Kafka**: 메시지 큐지만 데이터베이스처럼 **영속성 보장**
- **ElasticSearch**: 검색엔진이지만 일부는 DB처럼 사용

즉, 단일 도구로는 애플리케이션의 모든 요구사항을 충족시키기 어려워졌고, **여러 도구를 조합**해서 시스템을 만들어야 합니다.

그리고 이러한 조합의 책임은 결국 **애플리케이션 코드**와 개발자에게 있습니다.

## 데이터 시스템의 3대 목표

데이터 시스템을 설계할 때 가장 중요한 3가지 비기능적 요구사항이 있습니다.

바로 **신뢰성(Reliability), 확장성(Scalability), 유지보수성(Maintainability)** 입니다.

### 1. 신뢰성 (Reliability)

**정의**: 시스템이 결함이 발생하더라도 **사용자가 기대한 기능을 올바르게 수행**하는 능력

- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

이와 같이 올바르게 동작하는 경우, 

무언가 잘못되더라도 지속적으로 올바르게 동작함을 신뢰성으로 이해합니다.

**결함(Fault) vs 장애(Failure)**

- **결함**: 시스템 일부 구성 요소가 사양과 다르게 동작하는 것
- **장애**: 사용자에게 필요한 서비스를 제공하지 못하는 상태

좋은 시스템은 "결함은 있어도 장애로 이어지지 않도록" 설계됩니다. 

이를 **내결함성(Fault-Tolerance)** 이라고 부릅니다.

**결함의 세 가지 유형**

1. **하드웨어 결함**: 디스크 고장, 램 오류, 전원 장애 → 보통 **중복(Replication, RAID)** 으로 해결
2. **소프트웨어 오류**: 특정 입력에서 전체 서비스 다운 → 격리, 모니터링, 자동화된 재시작 필요
3. **인적 오류**: 운영자, 사람의 인한 실수(human error) → 롤백, 샌드박스 환경, 단계적 배포(예: 카나리 배포)

💡 **실제 사례**: 넷플릭스 **Chaos Monkey** → 일부 서버를 랜덤으로 죽여서 내결함성을 훈련

### 2. 확장성 (Scalability)

**정의**: 부하(Load)가 증가해도 시스템 성능을 유지할 수 있는 능력

여기서 중요한 점은 “X 시스템은 확장 가능하다”라는 평가가 아니라
“부하가 특정 방식으로 증가할 때 어떤 선택지가 있으며, 자원을 어떻게 추가해야 성능을 유지할 수 있을까?” 라는 질문으로 접근해야 한다는 점입니다.

성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가입니다.

확장성을 논하기 전에 먼저 **현재 시스템 부하를 정량적으로 표현**할 수 있어야 합니다.

**이를 부하 매개변수(Load Parameter)** 와 **성능 지표**를 정의해야 합니다.

- 웹 서버 → 초당 요청 수 (QPS, RPS)
- DB → 읽기:쓰기 비율
- 채팅 서비스 → 동시 활성 사용자 수
- 캐시 → 적중률(hit ratio)

### 📌 트위터 사례

- **트윗 작성 (쓰기)**: 평균 초당 4.6k, 피크일 때 12k 이상
- **홈 타임라인 (읽기)**: 초당 300k 요청

트위터의 문제는 쓰기보다 **읽기 부하**가 훨씬 크다는 점이었습니다.
여기에 더해 "팬아웃(Fan-out)"이 핵심 병목을 만듭니다.

**접근 방식 1**: 읽기 시점 계산

- 사용자가 타임라인 요청 시 → 팔로우한 사용자들의 트윗을 모두 가져와 합치고 정렬
- 팔로잉 목록을 조회 → 각 트윗 합치기
- **읽기 요청이 폭발적일 때 병목 발생**

**접근 방식 2**: 쓰기 시점 팬아웃

- 사용자가 트윗 작성 시 → 모든 팔로워의 타임라인 캐시에 미리 삽입
- 읽기는 빠르지만, 팔로워가 수천만 명인 경우 **쓰기 비용 폭발**

**실제 해결책**: **혼합 전략**

- 일반 사용자는 쓰기 시점을 팬아웃 방식
- 유명인 계정(수천만 팔로워)은 읽기 요청 시점에 합산

확장성은 정답이 아니라 **워크로드 특성에 맞는 트레이드오프 선택**

### 성능(Performance) 기술하기

확장성을 논하려면 **성능 지표(metric)** 도 정의해야 합니다.

대표적인 지표는 **처리량(Throughput)** 과 **응답 시간(Response Time)** 입니다.

- **처리량(Throughput)**: 초당 처리 가능한 요청 수 (ex: Hadoop 배치 처리 → 초당 레코드 수)
- **응답 시간(Response Time)**: 클라이언트 입장에서 요청~응답까지 걸린 시간

### 평균 vs 백분위(Percentile)

응답 시간은 항상 변동이 있기 때문에 **평균값만 보는 것은 위험**합니다.

예시:

- 평균 응답 시간 = 200ms
- 하지만 상위 1% 요청은 3초 이상 지연될 수 있음

➡️ 따라서 **백분위(Percentile)** 로 성능을 보는 것이 더 현실적입니다.

- **p50 (중앙값)**: 절반의 요청이 이 시간보다 빠름
- **p95, p99, p99.9**: 상위 꼬리 지연(tail latency)을 측정

💡 **아마존 사례**

- 내부 SLA를 “p99 응답 시간 < 1초”로 설정
- 응답 시간이 100ms 늘어나면 매출이 1% 감소
- 1초 늘어나면 고객 만족도가 16% 감소

👉 꼬리 지연은 소수 사용자만 겪더라도 실제 비즈니스에 큰 영향을 줌

---

### 5) 부하 대응 방식

부하가 늘어날 때 대응하는 방법은 크게 두 가지입니다.

1. **수직 확장 (Vertical Scaling)**
    - 더 강력한 장비로 교체 (CPU 코어, 메모리 증설)
    - 단순하지만 비용이 급격히 증가
2. **수평 확장 (Horizontal Scaling)**
    - 더 많은 장비로 부하를 분산 (비공유 아키텍처)
    - 복잡도가 증가하지만 대규모 시스템에서는 필수

또한 일부 시스템은 **탄력적(Elastic)** 으로 자동 확장 가능하지만,

운영 단순성을 위해 수동 확장을 선택하는 경우도 많습니다.

---

### 6) 핵심 인사이트

- 확장성에는 **범용 해답이 없다**
- 시스템의 **주요 부하 특성(읽기/쓰기 비율, 데이터 크기, 응답 요구)** 에 맞는 전략을 선택해야 한다
- 스타트업처럼 초기 단계라면, 미래의 부하를 과도하게 대비하기보다 **빠른 기능 개선과 반복**이 더 중요하다

### 3. 유지보수성 (Maintainability)

**정의**: 시간이 지나도 시스템이 쉽게 운영되고, 수정·개선될 수 있는 능력

유지보수에는 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등이 있습니다.

### 소프트웨어 시스템 설계 세 가지 원칙

다음의 소프트웨어 시스템 설계 세 가지 원칙을 염두에 두고 시스템을 생각하려고 노력합니다.

1. **운용성 (Operability)**
    - 운영자가 시스템을 안정적으로 관리할 수 있어야 함
    - 좋은 모니터링, 자동화, 장애 대응 절차 필요
2. **단순성 (Simplicity)**
    - 불필요한 복잡도를 줄여야 함
    - 좋은 추상화(SQL, API, 언어 레벨 추상화)는 복잡도를 감춤
    - 복잡도가 쌓이면 "Big Ball of Mud(진흙 덩어리)"가 됨
3. **발전성 (Evolvability)**
    - 요구사항 변화에 쉽게 적응할 수 있어야 함
    - 리팩토링, 애자일, 테스트 주도 개발(TDD) → 시스템을 변화에 강하게 만듦

- 쉬운 비유: 데이터 시스템 = 도시 인프라
    
    데이터 시스템을 도시 인프라에 비유하면 이해가 쉽습니다.
    
    - **데이터베이스(DB)** → 수도관 (항상 물을 저장하고 공급)
    - **캐시(Cache)** → 물탱크 (빠른 공급을 위해 임시 저장)
    - **메시지 큐** → 택배 물류 (비동기 전달)
    - **검색엔진** → 내비게이션 (빠른 길 찾기)
    - **배치 처리** → 야간 쓰레기 수거 (대량 작업을 한 번에 처리)
    
    도시가 커질수록 수도, 전기, 교통을 확장해야 하는 것처럼 
    
    애플리케이션도 **확장성, 신뢰성, 유지보수성**을 확보해야 합니다.
    

## 정리

1. **신뢰성**: 결함이 있어도 시스템은 멈추지 않는다
2. **확장성**: 부하 증가에도 성능을 유지할 수 있는 전략 필요
3. **유지보수성**: 장기적으로 엔지니어가 쉽게 다룰 수 있어야 한다